<!DOCTYPE html>
<html>
<head>
    <title>Page Title</title>
    <style>
        #container{
            display: flex;
            height: 1000px;
            width: 1000px;
        }
        #one{
            background-color: red;
        }
        #two{
            background-color: blue;
        }
    </style>
</head>
<body>
<!-- 
    TypeScript fundamentals
    - Improved form of Javascript with data types
    - const keeps the first value, but attributes can still be manipulated
    - Different data types give you different reserved space in memory
    - TypeScript is a superset of Javascript
    - "old javascript" = 1990-2005 roughly
    - strings can include external variables
        - const message:string = 'Hi my name is ${name}!'
    - let names:string[] = ["ab","bc"];
        - TypeScript cares what's in arrays whereas old javascript didnt
    - tuples can have different data types in the
        - let beerAbv:[string,number] = ["21","ipa"];
    - enums give a name to a set of numbers
        - enum Dock{TOP,RIGHT,BOTTOM,LEFT}
        - Dock.RIGHT will give you the RIGHT value
    - default language of Angular is TypeScript
    - enums can be achieved in javascript by using a TypeScript compiler (TSC)
    - let visible:any = true;
        - this will be initialized as boolean and can be changed later (like to a string or something else)
        - need to cast to the proper data type to use APIs like "string.length"
        - Example of casting: 
            - let len:number = (val as string).length;
    - declaring variables with 'var' can also accept any data type
    - if javascript fails to compile most times everything will not render properly, if at all
    - TypeScript introduces void or a return type that has no value
    - Example of void:
        function debugIt(msg:string):void {
            console.log(msg)
        };
    - never can be used to indicate values that should never occur
    - arrow functions are another way to define a function
        (message: string) => {};
    - undefined and null are subtypes of all other types in TypeScript
    - === is a strict equality check which means it keeps values compared intact
        var a = 1;
        var b = "1";
        if ( a === b ){
            will not return true
        }
        if ( a !== b ){
            will return true
        }o
    - in old javascript need to use parseInt to get a string to an int
    - lint and tslint can be used to check your javascript or typescript for errors or bad practices

    ***Averager code review***
    - npminit creates the package.json file
        - devDependencies dont get deployed because theyre just used for testing and writing code
        - dependencies get deployed 
    - "tsc-init" from within a folder will install things necessary for ts to run
    - jquery makes using javascript easier
        - wraps document.getElementById and stuff like that to make js easier to use
        - document.getElementById(someButton) is without jquery and with jquery its $("#getAverage")
        - need to ''"import * as $ from "jquery"' to get things following $ to feed through jquery
    - package.json specifies the main function which is a single javascript file that should be
    the starting point for the whole app
    - "npm install" will load all the packages package.json indicates and put them in npm_modules directory
    - "npm run x" will compile the app where x is defined in packages.json

    ***Control Structures***
    - contine will continue a loop instead of exiting if an if statement is invoked and you want to continue
    the loop after something happens
    - (param) => { statements } is a shorthand way to define functions called arrow functions
    - () => { statements } takes no parameters
    - arrow functions are always anonymous (no name)
    - calling a function with parenthesis like "foo()"" calls the function when the code runs. You want to
    use a function pointer and just call "foo" so that the function only gets called when the enclosing
    javascript function runs.
    - anonymous functions wont be called at runtime they'll only be called when run
        - function(event, a, b){}; or (event, a, b) => {}; will only be called when run
        - foo() will be called immediately

    ***Flexbox***
    - better way to do grid development (rows and columns)
    - display=flex and its a div container
    - every item in the flexbox has its own space in the container

    ***React Converter App***
    - package.json includes all the versions and dependencies
    - viewport is a default that should always be in your webpage
    - <noscript> tag is used to show a script when your browser doesnt have javascript
    - all HTML is put in <div id="root"></div>
    - manifest.json lists names, start_url, etc.
    - industry best practice is to put app under src folder
    - index.js is the entry point to inject stuff into that root div on the HTML page
    - to build a react component you extend the React.Component class
    - in constructor() call your parent first with super() to make sure you can be built properly
    before you continue
        - this.state is used to define what an object currently "knows" and you initialize the state
        in the constructor
    - JSX = javascript extended, which allows you to add HTML in a javascript file and have it be treated as an object
    - render() is part of React.Component and it's what the web app shows the user at the appropriate time
-->
    <div id="container">
        <div id="one"></div>
        <div id="two"></div>
    </div>
</body>
</html>